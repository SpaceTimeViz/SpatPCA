# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
#'
#' @title  Regularized PCA for spatial data
#'
#' @description Produce spatial dominant patterns and spatial predictions at the designated locations according to the specified tuning parameters or the selected tuning parameters by the M-fold cross-validation.
#'
#' @param x Location matrix (\eqn{p \times d}). Each row is a location. \eqn{d} is the dimension of locations
#' @param Y Data matrix (\eqn{n \times p}) stores the values at \eqn{p} locations with sample size \eqn{n}.
#' @param K Optional user-supplied number of eigenfunctions; default is NULL. If K is NULL or is_K_selected is TRUE, K is selected automatically.
#' @param is_K_selected If TRUE, K is selected automatically; otherwise, is_K_selected is set to be user-supplied K. Default depends on user-supplied K.
#' @param tau1 Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence. If NULL, 10 tau1 values in a range are used.
#' @param tau2 Optional user-supplied numeric vector of a nonnegative sparseness parameter sequence. If NULL, none of tau2 is used.
#' @param gamma Optional user-supplied numeric vector of a nonnegative tuning parameter sequence. If NULL, 10 values in a range are used.
#' @param x_new New location matrix. If NULL, it is x.
#' @param M Optional number of folds; default is 5.
#' @param is_Y_centered If TRUE, center the columns of Y. Default is FALSE.
#' @param maxit Maximum number of iterations. Default value is 100.
#' @param thr Threshold for convergence. Default value is \eqn{10^{-4}}.
#' @param num_cores Number of cores used to parallel computing. Default value is NULL (See `RcppParallel::defaultNumThreads()`)
#'
#' @return A list of objects including
#' \item{eigenfn}{Estimated eigenfunctions at the new locations, x_new.}
#' \item{selected_K}{Selected K based on CV. Execute the algorithm when `is_K_selected` is `TRUE`.}
#' \item{prediction}{Prediction of Y at the new locations, x_new.}
#' \item{selected_tau1}{Selected tau1.}
#' \item{selected_tau2}{Selected tau2.}
#' \item{selected_gamma}{Selected gamma.}
#' \item{cv_score_tau1}{cv scores for tau1.}
#' \item{cv_score_tau2}{cv scores for tau2.}
#' \item{cv_score_gamma}{cv scores for gamma.}
#' \item{tau1}{Sequence of tau1-values used in the process.}
#' \item{tau2}{Sequence of tau2-values used in the process.}
#' \item{gamma}{Sequence of gamma-values used in the process.}
#' \item{Yc}{If is_Y_centered is TRUE, Yc is the centered Y; else, Yc is equal to Y.}
#'
#' @details An ADMM form of the proposed objective function is written as
#' \deqn{\min_{\mathbf{\Phi}} \|\mathbf{Y}-\mathbf{Y}\mathbf{\Phi}\mathbf{\Phi}'\|^2_F +\tau_1\mbox{tr}(\mathbf{\Phi}^T\mathbf{\Omega}\mathbf{\Phi})+\tau_2\sum_{k=1}^K\sum_{j=1}^p |\phi_{jk}|,}
#' \eqn{\mbox{subject to $ \mathbf{\Phi}^T\mathbf{\Phi}=\mathbf{I}_K$,}} where \eqn{\mathbf{Y}} is a data matrix, \eqn{{\mathbf{\Omega}}} is a smoothness matrix, and \eqn{\mathbf{\Phi}=\{\phi_{jk}\}}.
#' @export
#' @author Wen-Ting Wang and Hsin-Cheng Huang
#' @references Wang, W.-T. and Huang, H.-C. (2017). Regularized principal component analysis for spatial data. \emph{Journal of Computational and Graphical Statistics} \bold{26} 14-25.
#' @examples
#' # The following examples only use two threads for parallel computing.
#' ## 1D: regular locations
#' x_1D <- as.matrix(seq(-5, 5, length = 50))
#' Phi_1D <- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
#' set.seed(1234)
#' Y_1D <- rnorm(n = 100, sd = 3) %*% t(Phi_1D) + matrix(rnorm(n = 100 * 50), 100, 50)
#' cv_1D <- spatpca(x = x_1D, Y = Y_1D, num_cores = 2)
#' plot(x_1D, cv_1D$eigenfn[, 1], type = "l", main = "1st eigenfunction")
#' lines(x_1D, svd(Y_1D)$v[, 1], col = "red")
#' legend("topleft", c("SpatPCA", "PCA"), lty = 1:1, col = 1:2)
#'
#' \donttest{
#' # The following examples will be executed more than 5 secs or including other libraries.
#' ## 1D: artificial irregular locations
#' rm_loc <- sample(1:50, 20)
#' x_1Drm <- x_1D[-rm_loc]
#' Y_1Drm <- Y_1D[,-rm_loc]
#' x_1Dnew <- as.matrix(seq(-5, 5, length = 100))
#' cv_1D <- spatpca(x = x_1Drm, Y = Y_1Drm, tau2 = 1:100, x_new = x_1Dnew)
#' plot(x_1Dnew, cv_1D$eigenfn, type = "l", main = "eigenfunction")
#' plot(cv_1D$prediction[, 50],
#'      xlab = "n",
#'      ylab = "prediction",
#'      type = "l",
#'      main = paste("prediction at x = ", x_1Dnew[50]))
#' ## 2D: Daily 8-hour ozone averages for sites in the Midwest (USA)
#' library(fields)
#' library(pracma)
#' library(maps)
#' data(ozone2)
#' x <- ozone2$lon.lat
#' Y <- ozone2$y
#' date <- as.Date(ozone2$date, format = "%y%m%d")
#' rmna <- !colSums(is.na(Y))
#' YY <- matrix(Y[, rmna], nrow = nrow(Y))
#' YY <- detrend(YY, "linear")
#' xx <- x[rmna, ]
#' cv <- spatpca(x = xx, Y = YY)
#' quilt.plot(xx, cv$eigenfn[,1])
#' map("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), add = TRUE)
#' map.text("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), cex = 2, add = TRUE)
#' plot(date, YY %*% cv$eigenfn[,1], type = "l", ylab = "1st Principal Component")
#' ### new loactions
#' new_p <- 200
#' x_lon <- seq(min(xx[, 1]), max(xx[, 1]), length = new_p)
#' x_lat <- seq(min(xx[, 2]), max(xx[, 2]), length = new_p)
#' xx_new <- as.matrix(expand.grid(x = x_lon, y = x_lat))
#' eof <- spatpca(x = xx,
#'                Y = YY,
#'                K = cv$selected_K, 
#'                tau1 = cv$selected_tau1, 
#'                tau2 = cv$selected_tau2, 
#'                x_new = xx_new)
#' quilt.plot(xx_new, eof$eigenfn[,1],
#'            nx = new_p, 
#'            ny = new_p, 
#'            xlab = "lon.", 
#'            ylab = "lat.")
#' map("state", xlim = range(x_lon), ylim = range(x_lat), add = TRUE)
#' map.text("state", xlim = range(x_lon), ylim = range(x_lat), cex = 2, add = TRUE)
#' ## 3D: regular locations
#' p <- 10
#' x <- y <- z <- as.matrix(seq(-5, 5, length = p))
#' d <- expand.grid(x, y, z)
#' Phi_3D <- rowSums(exp(-d^2)) / norm(as.matrix(rowSums(exp(-d^2))), "F")
#' Y_3D <- rnorm(n = 100, sd = 3) %*% t(Phi_3D) + matrix(rnorm(n = 100 * p^3), 100, p^3)
#' cv_3D <- spatpca(x = d, Y = Y_3D, tau2 = seq(0, 1000, length = 10))
#' library(plot3D)
#' library(RColorBrewer)
#' cols <- colorRampPalette(brewer.pal(9, "Blues"))(p)
#' isosurf3D(x, y, z,
#'          colvar = array(cv_3D$eigenfn[, 1], c(p, p, p)),
#'          level= seq(min(cv_3D$eigenfn[, 1]), max(cv_3D$eigenfn[, 1]), length = p),
#'          ticktype = "detailed",
#'          colkey = list(side = 1),
#'          col = cols)
#' }
spatpca <- function(x,
                    Y,
                    M = 5,
                    K = NULL,
                    is_K_selected = ifelse(is.null(K), TRUE, FALSE),
                    tau1 = NULL,
                    tau2 = NULL,
                    gamma = NULL,
                    x_new = NULL,
                    is_Y_centered = FALSE,
                    maxit = 100,
                    thr = 1e-04,
                    num_cores = NULL) {
  call2 <- match.call()
  setCores(num_cores)

  x <- as.matrix(x)
  p <- ncol(Y)
  n <- nrow(Y)
  if (nrow(x) != p) {
    stop("The number of rows of x should be equal to the number of columns of Y.")
  }
  if (nrow(x) < 3) {
    stop("Number of locations must be larger than 2.")
  }
  if (ncol(x) > 3) {
    stop("Dimension of locations must be less than 4.")
  }
  if (M >= n) {
    stop("Number of folds must be less than sample size.")
  }
  if (!is.null(K)) {
    if (K > min(floor(n - n / M), p)) {
      K <- min(floor(n - n / M), p)
      warning("K must be smaller than min(floor(n - n/M), p).")
    }
  }
  # Remove the mean trend of Y
  if (is_Y_centered) {
    Y <- Y - apply(Y, 2, "mean")
  }
  # Initialize candidates of tuning parameters
  if (is.null(tau2)) {
    tau2 <- 0
    num_tau2 <- 1
  } else {
    num_tau2 <- length(tau2)
  }
  if (is.null(tau1)) {
    num_tau1 <- 11
    tau1 <- c(0, exp(seq(log(1e-6), 0, length = num_tau1 - 1)))
  } else {
    num_tau1 <- length(tau1)
  }

  if (M < 2 && (num_tau1 > 1 || num_tau2 > 1)) {
    num_tau1 <- num_tau2 <- 1
    warning("Only produce the result based on the largest tau1 and largest tau2.")
  }

  stra <- sample(rep(1:M, length.out = nrow(Y)))
  if (is.null(gamma)) {
    num_gamma <- 11
    svd_Y_partial <- svd(Y[which(stra != 1), ])
    max_gamma <- svd_Y_partial$d[1]^2 / nrow(Y[which(stra != 1), ])
    log_scale_candidates <-
      seq(log(max_gamma / 1e4), log(max_gamma), length = num_gamma - 1)
    gamma <- c(0, log_scale_candidates)
  }

  if (dim(x)[2] == 1) {
    min_x <- min(x)
    max_x <- max(x)
    x <- (x - min_x) / (max_x - min_x)
    if (!is.null(x_new)) {
      x_new <- (x_new - min_x) / (max_x - min_x)
    }
  }

  if (num_tau2 == 1 && tau2 > 0) {
    l2 <- ifelse(tau2 != 0,
      c(0, exp(seq(log(tau2 / 1e4), log(tau2), length = 10))),
      tau2
    )
  } else {
    l2 <- 1
  }

  if (is_K_selected) {
    cv_result <- spatpcaCV(x, Y, M, 1, tau1, tau2, gamma, stra, maxit, thr, l2)
    for (k in 2:min(floor(n - n / M), p)) {
      cv_new_result <- spatpcaCV(x, Y, M, k, tau1, tau2, gamma, stra, maxit, thr, l2)
      difference <- cv_result$selected_gamma - cv_new_result$selected_gamma
      if (difference <= 0 || abs(difference) <= 1e-8) {
        break
      }
      cv_result <- cv_new_result
    }
    selected_K <- k - 1
  }
  else {
    cv_result <- spatpcaCV(x, Y, M, K, tau1, tau2, gamma, stra, maxit, thr, l2)
    selected_K <- K
  }

  selected_tau1 <- cv_result$selected_tau1
  selected_tau2 <- cv_result$selected_tau2
  selected_gamma <- cv_result$selected_gamma
  cv_score_tau1 <- cv_result$cv_score_tau1
  cv_score_tau2 <- cv_result$cv_score_tau2
  cv_score_gamma <- cv_result$cv_score_gamma
  estimated_eigenfn <- cv_result$estimated_eigenfn
  if (is.null(x_new)) {
    x_new <- x
    predicted_eigenfn <- estimated_eigenfn
  }
  else {
    x_new <- as.matrix(x_new)
    predicted_eigenfn <- eigenFunction(x_new, x, estimated_eigenfn)
  }

  spatial_prediction <- spatialPrediction(estimated_eigenfn, Y, selected_gamma, predicted_eigenfn)
  prediction <- spatial_prediction$predict

  obj.cv <- list(
    call = call2,
    eigenfn = estimated_eigenfn,
    prediction = prediction,
    selected_K = K,
    selected_tau1 = selected_tau1,
    selected_tau2 = selected_tau2,
    selected_gamma = selected_gamma,
    cv_score_tau1 = cv_score_tau1,
    cv_score_tau2 = cv_score_tau2,
    cv_score_gamma = cv_score_gamma,
    tau1 = tau1,
    tau2 = tau2,
    gamma = gamma,
    Yc = Y
  )
  class(obj.cv) <- "spatpca"
  return(obj.cv)
}


#'
#' @title  Display the cross-validation results
#'
#' @description Display the M-fold cross-validation results
#'
#' @param x An spatpca class object for `plot` method
#' @param ... Not used directly
#' @seealso \link{spatpca}
#'
#' @export
#' @method plot spatpca
#' @examples
#' x_1D <- as.matrix(seq(-5, 5, length = 10))
#' Phi_1D <- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
#' set.seed(1234)
#' Y_1D <- rnorm(n = 100, sd = 3) %*% t(Phi_1D) + matrix(rnorm(n = 100 * 10), 100, 10)
#' cv_1D <- spatpca(x = x_1D, Y = Y_1D, num_cores = 2)
#' plot(cv_1D)
#
plot.spatpca <- function(x, ...) {
  if (class(x) != "spatpca") {
    stop("Invalid object! Please enter a `spatpca` object")
  }

  # Set the default theme
  theme_set(
    theme_bw() +
      theme(
        text = element_text(size = 16),
        legend.position = "none",
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5)
      )
  )
  cv_dataframe <- rbind(
    data.frame(
      type = "tau1 given tau2 = 0",
      parameter = array(x$tau1),
      cv = array(x$cv_score_tau1)
    ),
    data.frame(
      type = "tau2 given selected tau1",
      parameter = array(x$tau2),
      cv = array(x$cv_score_tau2)
    ),
    data.frame(
      type = "gamma given selected tau1 and tau2",
      parameter = array(x$gamma),
      cv = array(x$cv_score_gamma)
    )
  )
  result <-
    ggplot(cv_dataframe, aes(x = parameter, y = cv, color = type)) +
    geom_line(size = 1.5) +
    facet_grid(scales = "free", . ~ type)

  return(suppressMessages(print(result)))
}
